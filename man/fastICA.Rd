% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fastICA.R
\name{fastICA}
\alias{fastICA}
\title{Fast Independent Component Analysis}
\usage{
fastICA(
  X,
  n.comp,
  alg.typ = c("parallel", "deflation"),
  fun = c("logcosh", "exp", "cube"),
  alpha = 1,
  whiten.method = c("spectra", "eigen", "svd"),
  maxit = 200L,
  tol = 1e-04,
  verbose = FALSE,
  n.threads = 0L,
  seed = NULL
)
}
\arguments{
\item{X}{A numeric matrix (observations x variables) or sparse dgCMatrix.
Rows are observations, columns are variables.}

\item{n.comp}{Number of independent components to extract.
Must be less than or equal to min(nrow(X), ncol(X)).}

\item{alg.typ}{Algorithm type: \code{"parallel"} (default, symmetric
orthogonalization) or \code{"deflation"} (sequential extraction).}

\item{fun}{Nonlinearity function: \code{"logcosh"} (default, most robust),
\code{"exp"} (good for super-Gaussian), or \code{"cube"} (kurtosis-based).}

\item{alpha}{Parameter for logcosh nonlinearity, between 1 and 2.
Default is 1.0. Higher values approach kurtosis.}

\item{whiten.method}{Whitening method: \code{"spectra"} (default, fastest -
computes only top-k eigenvalues using Lanczos iteration), \code{"eigen"}
(full eigendecomposition of covariance matrix), or \code{"svd"}
(SVD-based, most numerically stable for ill-conditioned data).}

\item{maxit}{Maximum number of iterations. Default is 200.}

\item{tol}{Convergence tolerance. Algorithm stops when the change in
unmixing matrix is below this threshold. Default is 1e-4.}

\item{verbose}{Logical, print progress messages. Default is FALSE.}

\item{n.threads}{Number of OpenMP threads for parallel algorithm.
Default is 0 (auto-detect maximum available).}

\item{seed}{Random seed for reproducibility. Default is NULL (random).}
}
\value{
An \code{\linkS4class{ICAResult}} object containing:
\describe{
  \item{S}{Matrix of independent components (n.comp x n observations).
    Each row is one independent component.}
  \item{A}{Mixing matrix (variables x n.comp). Maps from IC space to
    original variable space: X_centered = A \%*\% S}
  \item{W}{Unmixing matrix (n.comp x whitened dimension). Applied to
    whitened data to get ICs: S = W \%*\% X_whitened}
  \item{K}{Whitening matrix (variables x whitened dimension). Projects
    centered data to whitened space: X_whitened = X_centered \%*\% K}
  \item{center}{Column means used for centering}
  \item{iterations}{Number of iterations performed}
  \item{converged}{Logical indicating if algorithm converged}
}
}
\description{
Performs Independent Component Analysis using the FastICA algorithm
with optimized C++ implementation via Eigen and OpenMP.
}
\details{
FastICA is a fixed-point iteration algorithm that maximizes non-Gaussianity
to find independent components. This implementation uses:

\itemize{
  \item Eigen C++ library for fast linear algebra
  \item OpenMP for parallel computation in the symmetric algorithm
  \item Spectra library for truncated eigendecomposition (default, fastest)
  \item Pre-allocated matrices to minimize memory allocation overhead
}

The \strong{parallel} algorithm extracts all components simultaneously
using symmetric orthogonalization. It is typically faster and more stable.

The \strong{deflation} algorithm extracts components one at a time using
Gram-Schmidt orthogonalization. It may be preferred when extracting only
a few components.
}
\section{Nonlinearity Functions}{

\describe{
  \item{logcosh}{g(u) = tanh(alpha*u). Most robust choice, works well for
    both sub- and super-Gaussian distributions.}
  \item{exp}{g(u) = u*exp(-u^2/2). Good for super-Gaussian distributions
    with heavy tails.}
  \item{cube}{g(u) = u^3. Simplest, equivalent to maximizing kurtosis.
    Less robust to outliers.}
}
}

\examples{
# Generate mixed signals (cocktail party problem)
set.seed(42)
n <- 1000

# Create two independent source signals
S <- cbind(
  sin(seq(0, 8*pi, length.out = n)),           # Sinusoid
  ((1:n \%\% 50) - 25) / 25                       # Sawtooth
)

# Create random mixing matrix
A <- matrix(c(0.5, 0.8, 0.6, 0.3), 2, 2)

# Mix the signals
X <- S \%*\% A

# Recover independent components
result <- fastICA(X, n.comp = 2)

# Check convergence
print(result)

# Compare recovered vs original (allowing for sign/order permutation)
cor(t(result@S), S)

}
\references{
Hyvarinen, A. and Oja, E. (2000). Independent Component Analysis:
Algorithms and Applications. Neural Networks, 13(4-5):411-430.
}
\seealso{
\code{\link{predict,ICAResult-method}} for projecting new data
}
